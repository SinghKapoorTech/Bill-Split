---
title: Events Collection Schema
date: 2026-02-21
tags: [database, schema, firestore, events]
---

# `events` & `eventInvitations` Collections

The event functionality is split across two collections to manage the lifecycle of invites securely. Events represent formal organizational containers for shared bills (e.g., a vacation, a group dinner, a weekend event).

## `events` Collection

### Document ID
Auto-generated by Firestore.

### Schema (`Event`)

| Field            | Type              | Description                                                               |
| ---------------- | ----------------- | ------------------------------------------------------------------------- |
| `id`             | String            | The document ID.                                                          |
| `name`           | String            | Event display name.                                                       |
| `description`    | String (Optional) | Event context or details.                                                 |
| `ownerId`        | String            | UID of the event creator (**[Users](users.md)** ref).                     |
| `memberIds`      | Array of String   | Array of active UIDs in the trip.                                         |
| `pendingInvites` | Array of String   | Array of **email addresses** that have been invited but haven't accepted. |
| `createdAt`      | Timestamp         | Creation time.                                                            |
| `updatedAt`      | Timestamp         | Last modification time.                                                   |

---

## `eventInvitations` Collection
This collection tracks the status of invitations sent via email to join a event.

### Document ID
Auto-generated by Firestore.

### Schema (`EventInvitation`)

| Field | Type | Description |
|-------|------|-------------|
| `id` | String | Invitation ID. |
| `eventId` | String | Ref to the **`events`** collection. |
| `email` | String | The email address the invite was sent to. |
| `invitedBy` | String | UID of the user who sent the invite. |
| `status` | String | Enum: `'pending'` \| `'accepted'` \| `'declined'`. |
| `createdAt` | Timestamp | When the invite was sent. |
| `respondedAt` | Timestamp (Optional) | When the invite was acted upon. |

## Relationship Flow
1. **Invite Sent**: A new `eventInvitations` document is created with status `pending`. Simultaneously, the `email` string is pushed to the `pendingInvites` array on the event document.
2. **Invite Accepted**: The `eventInvitations` status shifts to `accepted`. The event document is updated: the email is removed from `pendingInvites`, and the resolving user's UID is pushed to `memberIds`.
3. **Usage**: A **[Bill](bills.md)** can optionally reference a `eventId`, associating that financial transaction directly with an event.

## Design Patterns & Best Practices

### Why attach `eventId` to Bills instead of an array of `billIds`?
When defining the relationship between Events and Bills, we attach the `eventId` to the Bill document and query for it (`where('eventId', '==', id)`), rather than maintaining a `billIds` array on the Event document.

- **The Solution**: By creating new Bill documents concurrently within the `bills` collection, users never lock the parent Event document. Furthermore, querying by `eventId` allows us to easily paginate and sort bills (e.g., `orderBy('createdAt', 'desc')`) without needing to fetch the entire Event document first or exceeding Firestore's 30-item limit for `in` queries.

## Event Ledger Architecture (`event_balances`)

Just like `friend_balances` tracks global debt between two friends over time, `event_balances` securely tracks the isolated mathematical debt *for a single event*.

### Schema (`EventLedger`)
| Field | Type | Description |
|-------|------|-------------|
| `id` | String | Same string as the `eventId` it tracks. |
| `eventId` | String | Reference to the Event. |
| `netBalances` | Record<string, number> | Map of single-user total net value `{ "user_id": 50 }`. Positive = they are owed money. Negative = they owe money. |
| `optimizedDebts` | Array of `OptimizedDebt` | `{ fromUserId, toUserId, amount }` - Algorithmically minimized transactions calculated in-memory during edits. |
| `processedBillIds` | Array of String | Array of footprint safeguards so bills double-added via network lag are ignored. |
| `lastUpdatedAt` | Timestamp | Standard timestamp. |

The math works via the same **Idempotent Delta Engine** (see [[Scalable-Ledger-Architecture]]). When a bill is reviewed, the Delta engine reads the bill's `eventBalancesApplied` footprint, reverses it entirely from the `event_balances` ledger, and applies the new exact net amounts.

When a user settles up from the Event UI, `markBillsAsSettledForUser` is called. The engine cascades backwards through old Event bills where the user owes money, marks the individual bills as Settled, zeroes out their footprint on the ledger, and effectively "Pays Off" the event using the exact same atomic transaction logic.
