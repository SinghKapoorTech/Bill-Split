---
title: Events Collection Schema
date: 2026-02-21
tags: [database, schema, firestore, events]
---

# `events` & `eventInvitations` Collections

The event functionality is split across two collections to manage the lifecycle of invites securely. Events represent formal organizational containers for shared bills (e.g., a vacation, a group dinner, a weekend event).

## `events` Collection

### Document ID
Auto-generated by Firestore.

### Schema (`Event`)

| Field            | Type              | Description                                                               |
| ---------------- | ----------------- | ------------------------------------------------------------------------- |
| `id`             | String            | The document ID.                                                          |
| `name`           | String            | Event display name.                                                       |
| `description`    | String (Optional) | Event context or details.                                                 |
| `ownerId`        | String            | UID of the event creator (**[Users](users.md)** ref).                     |
| `memberIds`      | Array of String   | Array of active UIDs in the trip.                                         |
| `pendingInvites` | Array of String   | Array of **email addresses** that have been invited but haven't accepted. |
| `createdAt`      | Timestamp         | Creation time.                                                            |
| `updatedAt`      | Timestamp         | Last modification time.                                                   |

---

## `eventInvitations` Collection
This collection tracks the status of invitations sent via email to join a event.

### Document ID
Auto-generated by Firestore.

### Schema (`EventInvitation`)

| Field | Type | Description |
|-------|------|-------------|
| `id` | String | Invitation ID. |
| `eventId` | String | Ref to the **`events`** collection. |
| `email` | String | The email address the invite was sent to. |
| `invitedBy` | String | UID of the user who sent the invite. |
| `status` | String | Enum: `'pending'` \| `'accepted'` \| `'declined'`. |
| `createdAt` | Timestamp | When the invite was sent. |
| `respondedAt` | Timestamp (Optional) | When the invite was acted upon. |

## Relationship Flow
1. **Invite Sent**: A new `eventInvitations` document is created with status `pending`. Simultaneously, the `email` string is pushed to the `pendingInvites` array on the event document.
2. **Invite Accepted**: The `eventInvitations` status shifts to `accepted`. The event document is updated: the email is removed from `pendingInvites`, and the resolving user's UID is pushed to `memberIds`.
3. **Usage**: A **[Bill](bills.md)** can optionally reference a `eventId`, associating that financial transaction directly with an event.

## Design Patterns & Best Practices

### Why attach `eventId` to Bills instead of an array of `billIds`?
When defining the relationship between Events and Bills, we attach the `eventId` to the Bill document and query for it (`where('eventId', '==', id)`), rather than maintaining a `billIds` array on the Event document.

This is a deliberate NoSQL design choice to avoid **Write Contention**:
- **The Problem**: If multiple users in an event attempt to upload receipts simultaneously, they would all need to update the same `billIds` array on the single Event document. Firestore limits sustained writes to a single document to ~1 per second. Exceeding this causes transactions to queue and eventually fail.
- **The Solution**: By creating new Bill documents concurrently within the `bills` collection, users never lock the parent Event document. Furthermore, querying by `eventId` allows us to easily paginate and sort bills (e.g., `orderBy('createdAt', 'desc')`) without needing to fetch the entire Event document first or exceeding Firestore's 30-item limit for `in` queries.
