---
title: Events Collection Schema
date: 2026-02-21
tags: [database, schema, firestore, events]
---

# `events` & `eventInvitations` Collections

The event functionality is split across two collections to manage the lifecycle of invites securely. Events represent formal organizational containers for shared bills (e.g., a vacation, a group dinner, a weekend event).

## `events` Collection

### Document ID
Auto-generated by Firestore.

### Schema (`Event`)

| Field            | Type              | Description                                                               |
| ---------------- | ----------------- | ------------------------------------------------------------------------- |
| `id`             | String            | The document ID.                                                          |
| `name`           | String            | Event display name.                                                       |
| `description`    | String (Optional) | Event context or details.                                                 |
| `ownerId`        | String            | UID of the event creator (**[Users](users.md)** ref).                     |
| `memberIds`      | Array of String   | Array of active UIDs in the trip.                                         |
| `pendingInvites` | Array of String   | Array of **email addresses** that have been invited but haven't accepted. |
| `createdAt`      | Timestamp         | Creation time.                                                            |
| `updatedAt`      | Timestamp         | Last modification time.                                                   |

---

## `eventInvitations` Collection
This collection tracks the status of invitations sent via email to join a event.

### Document ID
Auto-generated by Firestore.

### Schema (`EventInvitation`)

| Field | Type | Description |
|-------|------|-------------|
| `id` | String | Invitation ID. |
| `eventId` | String | Ref to the **`events`** collection. |
| `email` | String | The email address the invite was sent to. |
| `invitedBy` | String | UID of the user who sent the invite. |
| `status` | String | Enum: `'pending'` \| `'accepted'` \| `'declined'`. |
| `createdAt` | Timestamp | When the invite was sent. |
| `respondedAt` | Timestamp (Optional) | When the invite was acted upon. |

## Relationship Flow
1. **Invite Sent (Email)**: A new `eventInvitations` document is created with status `pending`. Simultaneously, the `email` string is pushed to the `pendingInvites` array on the event document.
2. **Direct Add (App User)**: When an existing app user is found via the invite search bar, their UID is pushed directly to the `memberIds` array, bypassing the email invitation process completely.
3. **Invite Accepted**: The `eventInvitations` status shifts to `accepted`. The event document is updated: the email is removed from `pendingInvites`, and the resolving user's UID is pushed to `memberIds`.
4. **Usage (Lazy Event Bills)**: A **[Bill](bills.md)** can optionally reference an `eventId`, associating that financial transaction directly with an event. To prevent database bloat from abandoned creations, clicking "+" inside an Event does *not* eagerly create a Firebase document. Instead, the UI navigates to `/bill/new` (Client-Side Draft) and passes the specific `targetEventId` (and `targetEventName`) in the router's memory state. When the draft engine detects a meaningful edit and executes a **JIT (Just-In-Time) Creation**, it injects the `targetEventId` into the payload and sets `billType: 'event'`, permanently linking the new bill to the parent event.

5. **Event Member Pre-Population**: When navigating to `/bill/new` from an event page, `AIScanView` detects `targetEventId` in the router state and immediately fetches the event document from Firestore. It then fetches `userService.getUserProfile()` for each `memberId` in parallel and maps the results to `Person[]` objects using `generateUserId(uid)` (i.e. `user-{uid}` format). These are seeded into the people state before the wizard renders, so all event members appear pre-populated in the People step.

6. **Bill List Refresh on Deletion**: When a bill is deleted from the Event Detail View, `deleteSession()` is called and on success the deleted bill is immediately filtered out of the local `eventBills` React state. This gives instant feedback without requiring a page reload or re-fetch.

## Design Patterns & Best Practices

### Why attach `eventId` to Bills instead of an array of `billIds`?
When defining the relationship between Events and Bills, we attach the `eventId` to the Bill document and query for it (`where('eventId', '==', id)`), rather than maintaining a `billIds` array on the Event document.

- **The Solution**: By creating new Bill documents concurrently within the `bills` collection, users never lock the parent Event document. Furthermore, querying by `eventId` allows us to easily paginate and sort bills (e.g., `orderBy('createdAt', 'desc')`) without needing to fetch the entire Event document first or exceeding Firestore's 30-item limit for `in` queries.

## Event Ledger Architecture (`event_balances`)

Just like `friend_balances` tracks global debt between two friends over time, `event_balances` securely tracks the isolated mathematical debt *for a single event*.

### Schema (`EventLedger`)
| Field | Type | Description |
|-------|------|-------------|
| `id` | String | Same string as the `eventId` it tracks. |
| `eventId` | String | Reference to the Event. |
| `netBalances` | Record<string, number> | Map of single-user total net value `{ "user_id": 50 }`. Positive = they are owed money. Negative = they owe money. |
| `optimizedDebts` | Array of `OptimizedDebt` | `{ fromUserId, toUserId, amount }` - Algorithmically minimized transactions calculated in-memory during edits. |
| `processedBillIds` | Array of String | Array of footprint safeguards so bills double-added via network lag are ignored. |
| `lastUpdatedAt` | Timestamp | Standard timestamp. |

The math works via the same **Idempotent Delta Engine** (see [[Scalable-Ledger-Architecture]]). When a bill is reviewed, the Delta engine reads the bill's `eventBalancesApplied` footprint, reverses it entirely from the `event_balances` ledger, and applies the new exact net amounts.

When a user settles up from the Event UI, `markBillsAsSettledForUser` is called. The engine cascades backwards through old Event bills where the user owes money, marks the individual bills as Settled, zeroes out their footprint on the ledger, and effectively "Pays Off" the event using the exact same atomic transaction logic.
